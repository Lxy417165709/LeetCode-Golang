
## 单调栈设计
1. 基本规律
	  1. 找 `nums[i]` 前面最后一个小于它的元素
	      - [x] 方案: 从前往后遍历，维护一个单调递增栈。
	  2. 找 `nums[i]` 前面最后一个大于它的元素
	      - [x] 方案: 从前往后遍历，维护一个单调递减栈。
	  3. 找 `nums[i]` 后面第一个小于它的元素
	      - [x] 方案: 从后往前遍历，维护一个单调递增栈。
	  4. 找 `nums[i]` 后面第一个大于它的元素
	      - [x] 方案: 从后往前遍历，维护一个单调递减栈。
2. 规律总结: 
    - [x] 遍历方向选择: 
        - 找前面的，那就从前向后遍历。
        - 找后面的，那就从后向前遍历。
    - [x] 元素关系选择: 
        - 找小于的，那就维护一个单调递增栈。
        - 找大于的，那就维护一个单调递减栈。
3. 框架
    ```go
    // nums是一个整型数组。
    stack := make([]int, 0)   // go语言没有栈结构，所以我用切片结构模拟栈
    for /* 遍历 */ {
        for len(stack) != 0 && /* 判断条件 */ {
            stack = stack[:len(stack)-1]
        }
        /*
            接下来栈会有两种情况:
                1. 栈为空: 说明没有满足条件的元素
                2. 栈非空: 那么栈顶就是满足条件的元素。 
            根据上面的情况执行相应操作。
        */
        stack = append(stack, nums[i])
    }
    ```
    - 「遍历」 指: 从前往后遍历 或 从后向前遍历。
        - 例子: `for i := 0;i < len(nums);i++` 这表示从前往后遍历。
    
    - 「判断条件」 指: 判断 数组元素 与 栈顶元素的关系，目的是形成相应的单调栈。
        - 例子: `nums[i] >= stack[len(stack)-1]` 这会形成单调递减栈。
4. 拓展问题:
    - [ ] 如果是要找大于等于、小于等于的元素时，那应该怎么做呢？
5. 练习题:
    - [ ] [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
