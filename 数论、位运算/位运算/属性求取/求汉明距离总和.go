package main

// 计算一个数组中，任意两个数之间汉明距离的总和。
func totalHammingDistance(nums []int) int {
	ans := 0
	// 由于数组中最大值为1e9,也就是说用31位二进制就能表示最大值了。
	// 			(x位2进制 可以表示的原码最大值为 2^x-1)
	for i := 0; i < 31; i++ {
		count := [2]int{} // 类似哈希结构，count[0]表示0有多少个，count[1]表示1有多少个
		for t := 0; t < len(nums); t++ {
			count[nums[t]&1]++
			nums[t] >>= 1
		}
		ans += count[0] * count[1]
	}
	return ans
}

/*
	题目链接:
		https://leetcode-cn.com/problems/total-hamming-distance/		汉明距离总和
*/

/*
	总结
	1.  思路是:
		比如有3个数(用二进制表示) (方向从右到左<-，分别为第1位、第2位...)
			第一个数 a: 1 0 0 1
			第二个数 b: 0 1 1 1
			第三个数 c: 0 0 1 1
		那么第一位上的汉明距离总和是0。
			为什么？ 因为a、b、c该位全是"1"，任意两个"1"的汉明距离是0，所以该位汉明距离总和是0。
		接下来看第二位，a的第二位是"0"，b、c的是"1"，此时该位的汉明距离就是2。
			为什么？ 由上面我们可以得到，该位的"0"有1个，"1"有2个，而任意一个"0"都可以和任意一个"1"组合，
					 一对组合可以产生的汉明距离为1，所以问题转换为了算多少对01组合，那么怎么计算呢？
					 答案就是该位"0"的个数乘以"1"的个数。
		接下来看第三位，可以看出，此时"0"有2个，"1"有1个，所以可以产生的汉明距离为2。
		接下来看第四位，可以看出，此时"0"有2个，"1"有1个，所以可以产生的汉明距离为2。
		于是: 总的汉明距离就是 0 + 2 + 2 + 2 = 6
*/
